Проект: сборка/отладка под MinGW (MSYS2 ucrt64) через CMake + VS Code

Содержание
1) Что здесь происходит в целом
2) Где лежат исходники и библиотеки
3) Как это конфигурируется и собирается (VS Code задачи)
4) Как это компилируется (стандарты/компилятор/флаги)
5) Как это линкуется (пути и библиотеки)
6) Как запускать и отлаживать
7) Ручная сборка из терминала (без VS Code)
8) Как добавлять новые исходники/заголовки/библиотеки
9) Переменная PATH и DLL (важно для запуска)
10) Типичные ошибки и как их диагностировать

1) Что здесь происходит в целом
- Система сборки: CMake.
- Генератор: "MinGW Makefiles" (под MSYS2/MinGW). MSVC не используется.
- Компилятор: g++ из MSYS2 ucrt64: C:/msys64/ucrt64/bin/g++.exe.
- Цель сборки: исполняемый файл build/app.exe.
- Отладчик: gdb из MSYS2 ucrt64: C:/msys64/ucrt64/bin/gdb.exe.

2) Где лежат исходники и библиотеки
- Исходники проекта: каталог src/ (все *.cpp собираются автоматически через file(GLOB_RECURSE .../src/*.cpp)).
- Заголовки проекта: каталог include/.
- Сторонние заголовки: libs/include (добавляется в include-пути через CMake).
- Сторонние бинарные библиотеки: внутри каталога libs/ (см. подпапки ниже).
- Конкретно сейчас для линковки заданы пути:
  - libs/glfw-3.4.bin.WIN64 — ожидается статическая libglfw3.a (или импортная библиотека, см. п.9).
  - libs/Glew_migw64 — используется при необходимости GLEW (по умолчанию выключено).
- Результаты сборки: build/ (создаётся автоматически).

3) Как это конфигурируется и собирается (VS Code задачи)
- Файл .vscode/tasks.json содержит две задачи:
  1) "cmake: configure (MinGW)" — команда:
     cmake -S . -B build -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Debug -DCMAKE_CXX_COMPILER=C:/msys64/ucrt64/bin/g++.exe
     Назначение: создать/обновить папку build/ с правильным генератором и компилятором.
  2) "cmake: build" — команда:
     cmake --build build --config Debug --parallel
     Назначение: собрать проект. Эта задача зависит от конфигурации (1).
- По умолчанию задача сборки — "cmake: build". Запускается через меню Run/Build или сочетание клавиш VS Code для сборки.

4) Как это компилируется (стандарты/компилятор/флаги)
- CMakeLists.txt:
  - C++ стандарт: C++20 (set(CMAKE_CXX_STANDARD 20), REQUIRED ON).
  - C стандарт: C17 (на случай, если появятся C-файлы).
  - Для не-MSVC (наш случай MinGW/GCC) добавлены предупреждения: -Wall -Wextra -Wpedantic.
- Компилятор задаётся при конфигурации: C:/msys64/ucrt64/bin/g++.exe.

5) Как это линкуется (пути и библиотеки)
- Пути к заголовкам:
  - include/ (локальные заголовки проекта)
  - libs/include (сторонние заголовки)
- Пути к библиотекам (target_link_directories(app PRIVATE ...)):
  - libs/glfw-3.4.bin.WIN64
  - libs/Glew_migw64
- Явно линкуемые библиотеки (target_link_libraries(app PRIVATE ...)):
  - glfw3 (статическая библиотека GLFW)
  - opengl32, gdi32, user32, shell32, advapi32, ole32, uuid, winmm, ws2_32 (системные зависимости под Windows, нужны GLFW/OpenGL)
  - glew32 — закомментировано; включать только когда реально используете GLEW (см. п.8 и п.9)

6) Как запускать и отлаживать
- Файл .vscode/launch.json содержит два профиля запуска:
  - "Debug (g++/gdb)": запускает build/app.exe под gdb, открывает внешний консольный экран; перед запуском выполняет сборку.
  - "Run compiled app": запускает build/app.exe под gdb без брейкпоинтов (как обычный запуск), тоже с внешней консолью; перед запуском выполняет сборку.
- Рабочая директория процесса: корень проекта (${workspaceFolder}).
- Отладчик: C:/msys64/ucrt64/bin/gdb.exe.
- В переменную окружения PATH для процесса добавляется: D:/progekt/curst_all_prod/curs_test/libs; затем системный PATH. Это нужно, чтобы .dll (если используются) находились во время запуска. Подробности — см. п.9.

7) Ручная сборка из терминала (без VS Code)
1) Конфигурация (один раз или при изменении CMake):
   cmake -S . -B build -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Debug -DCMAKE_CXX_COMPILER=C:/msys64/ucrt64/bin/g++.exe
2) Сборка:
   cmake --build build --config Debug --parallel
3) Запуск:
   build/app.exe

8) Как добавлять новые исходники/заголовки/библиотеки
- Новые .cpp просто кладите в src/ — они подхватятся автоматически (используется GLOB_RECURSE).
- Заголовки кладите в include/ (или подключайте из libs/include, если это сторонние).
- Подключение новой сторонней библиотеки:
  1) Положите .lib/.a/.dll/.dll.a в отдельную подпапку внутри libs/.
  2) Добавьте эту папку в target_link_directories(app PRIVATE ...).
  3) Добавьте нужные имена библиотек в target_link_libraries(app PRIVATE ...).
  4) Если библиотека требует заголовки — добавьте путь в target_include_directories(app ...), например в libs/include или отдельную папку.
- Пример для GLEW (если понадобится):
  1) В target_link_libraries(app PRIVATE ...) раскомментируйте glew32.
  2) Если линкуете статический GLEW, обычно требуется добавить define GLEW_STATIC и убедиться, что у вас есть соответствующая статическая библиотека (название может отличаться). Для динамического варианта потребуется glew32.dll доступный по PATH или рядом с app.exe.

9) Переменная PATH и DLL (важно для запуска)
- Сейчас в профилях запуска к PATH добавляется: D:/progekt/curst_all_prod/curs_test/libs; затем идёт системный PATH.
- Что это значит:
  - Если вы используете динамические библиотеки (например, glew32.dll или glfw3.dll), их можно положить либо:
    a) В D:/progekt/curst_all_prod/curs_test/libs (доступно через PATH из launch.json);
    b) Рядом с build/app.exe;
    c) В любую директорию, уже присутствующую в системном PATH (например, C:/msys64/ucrt64/bin для рантайм-библиотек GCC).
  - Для статической линковки glfw3 обычно .dll не требуется, но рантайм MinGW (libstdc++-6.dll, libgcc_s_*.dll, libwinpthread-1.dll) может понадобиться при запуске. Их обычно берут из C:/msys64/ucrt64/bin. Убедитесь, что этот путь есть в системном PATH, либо скопируйте нужные dll рядом с app.exe (или добавьте путь в launch.json/environment).

10) Типичные ошибки и как их диагностировать
- CMake не находит компилятор/генератор:
  - Проверьте наличие C:/msys64/ucrt64/bin/g++.exe и установленного набора MSYS2 ucrt64.
  - Удалите папку build/ и запустите конфигурацию заново.
- Linker error: cannot find -lglfw3 (или любая другая библиотека):
  - Проверьте, что в libs/glfw-3.4.bin.WIN64 действительно лежит libglfw3.a (или подходящая импортная библиотека под MinGW: libglfw3dll.a, если вы линкуете к dll-варианту).
  - Имя библиотеки в target_link_libraries должно соответствовать артефакту (например, для libglfw3.a достаточно указать glfw3).
  - Проверьте, что путь добавлен в target_link_directories(app PRIVATE ...).
- Запуск: отсутствуют нужные DLL:
  - Если при старте app.exe консоль ругается на отсутствующие .dll — добавьте соответствующую папку к PATH или положите .dll рядом с app.exe (см. п.9).
- Символы OpenGL/WinAPI не найдены:
  - Проверьте, что системные библиотеки opengl32, gdi32, user32 и прочие перечисленные в CMakeLists.txt присутствуют в target_link_libraries (они уже есть по умолчанию).
- Отладка не стартует:
  - Проверьте наличие C:/msys64/ucrt64/bin/gdb.exe.
  - Убедитесь, что build/app.exe существует (выполните сборку).

Где менять ключевые вещи
- Состав файлов/проектная логика: каталог src/ и include/.
- Пути к заголовкам/библиотекам и список линкуемых библиотек: CMakeLists.txt (target_include_directories, target_link_directories, target_link_libraries).
- Настройки конфигурации/сборки (генератор, компилятор): .vscode/tasks.json → задача "cmake: configure (MinGW)".
- Запуск/отладка (gdb, PATH, внешний терминал): .vscode/launch.json.

Кратко: обычный цикл работы
1) Добавили/изменили файлы в src/ и include/.
2) Собрали проект задачей "cmake: build" (она автоматически конфигурирует проект при необходимости).
3) Запустили "Debug (g++/gdb)" или "Run compiled app" из VS Code. При необходимости убедились, что в PATH доступны нужные .dll.


